#generate start y
DT[time == 1, y := a + tau*X_1 + .3*X_2]
# creating lag structure
for (year in c(2:N_T)){
DT[time == year, y := a + tau*X_1 + .3*X_2 +
+ .3*X_3 + .3*X_4 + .3*X_5 + .3*X_6 + .3*X_7  + .3*X_5 + .3*X_6 +
+ .3*X_7 + .3*X_8  + .3*X_9 + .3*X_10 +
rnorm(.N, mean=0, sd=1)]
}
# returning the data objects
return(DT)
}
DT <- DGP(N = 100 , N_T = 10, rho = .8, tau = 1, p = 10)
#DML
data_proc_base <- DataAPDAutoDML(x = c(paste0("X_", 2:10)), d = "X_1",
y = "y" , data = DT, poly_order = 3,
interactions = TRUE,
unit = "fixed", time = "time")
auto_base <- rlassoAutoDML(data_proc_base, est_type = "APD" )
auto_base$te
DGP <- function(N, N_T = 10, rho = .8, tau = 1, p = 10){
# drawing fixed effects
a <- rnorm(N, 0, 5)
# id number for person
fixed <- rep(1:N, each = N_T)     # fixed effect dummies
# time label
time <- rep(1:N_T,  N)     # time
# creating base data
DT <- data.table(fixed, time, a = rep(a, each = N_T))
# create covar
# Create a data table with random normal values
var_names <- paste0("X_", 1:p) # creates the variable names X_1 through X_100
covar_DT <- data.table(matrix(rnorm(N*N_T * p),
nrow = N*N_T, ncol = p,
dimnames = list(NULL, var_names)))
DT <- cbind(DT, covar_DT)
#generate start y
DT[time == 1, y := a + tau*X_1 + .3*X_2]
# creating lag structure
for (year in c(2:N_T)){
DT[time == year, y := a + tau*X_1 + .3*X_2 +
+ .3*X_3 + .3*X_4 + .3*X_5 + .3*X_6 + .3*X_7  + .3*X_5 + .3*X_6 +
+ .3*X_7 + .3*X_8  + .3*X_9 + .3*X_10 +
rnorm(.N, mean=0, sd=1)]
}
# returning the data objects
return(DT)
}
DT <- DGP(N = 100 , N_T = 10, rho = .8, tau = 1, p = 10)
#DML
data_proc_base <- DataAPDAutoDML(x = c(paste0("X_", 2:10)), d = "X_1",
y = "y" , data = DT, poly_order = 3,
interactions = TRUE,
unit = "fixed", time = "time")
auto_base <- rlassoAutoDML(data_proc_base, est_type = "APD" )
auto_base$te
DGP <- function(N, N_T = 10, rho = .8, tau = 1, p = 10){
# drawing fixed effects
a <- rnorm(N, 0, 5)
# id number for person
fixed <- rep(1:N, each = N_T)     # fixed effect dummies
# time label
time <- rep(1:N_T,  N)     # time
# creating base data
DT <- data.table(fixed, time, a = rep(a, each = N_T))
# create covar
# Create a data table with random normal values
var_names <- paste0("X_", 1:p) # creates the variable names X_1 through X_100
covar_DT <- data.table(matrix(rnorm(N*N_T * p),
nrow = N*N_T, ncol = p,
dimnames = list(NULL, var_names)))
DT <- cbind(DT, covar_DT)
#generate start y
DT[time == 1, y := a + tau*X_1 + .3*X_2]
# creating lag structure
for (year in c(2:N_T)){
DT[time == year, y := a + tau*X_1 + .3*X_2 +
+ .3*X_3 + .3*X_4 + .3*X_5 + .3*X_6 + .3*X_7  + .3*X_5 + .3*X_6 +
+ .3*X_7 + .3*X_8  + .3*X_9 + .3*X_10 +
rnorm(.N, mean=0, sd=1)]
}
# returning the data objects
return(DT)
}
DT <- DGP(N = 100 , N_T = 10, rho = .8, tau = 1, p = 10)
#DML
data_proc_base <- DataAPDAutoDML(x = c(paste0("X_", 2:10)), d = "X_1",
y = "y" , data = DT, poly_order = 3,
interactions = TRUE,
unit = "fixed", time = "time")
auto_base <- rlassoAutoDML(data_proc_base, est_type = "APD" )
auto_base$te
DGP <- function(N, N_T = 10, rho = .8, tau = 1, p = 10){
# drawing fixed effects
a <- rnorm(N, 0, 5)
# id number for person
fixed <- rep(1:N, each = N_T)     # fixed effect dummies
# time label
time <- rep(1:N_T,  N)     # time
# creating base data
DT <- data.table(fixed, time, a = rep(a, each = N_T))
# create covar
# Create a data table with random normal values
var_names <- paste0("X_", 1:p) # creates the variable names X_1 through X_100
covar_DT <- data.table(matrix(rnorm(N*N_T * p),
nrow = N*N_T, ncol = p,
dimnames = list(NULL, var_names)))
DT <- cbind(DT, covar_DT)
#generate start y
DT[time == 1, y := a + tau*X_1 + .3*X_2]
# creating lag structure
for (year in c(2:N_T)){
DT[time == year, y := a + tau*X_1 + .3*X_2 +
+ .3*X_3 + .3*X_4 + .3*X_5 + .3*X_6 + .3*X_7  + .3*X_5 + .3*X_6 +
+ .3*X_7 + .3*X_8  + .3*X_9 + .3*X_10 +
rnorm(.N, mean=0, sd=1)]
}
# returning the data objects
return(DT)
}
DT <- DGP(N = 100 , N_T = 10, rho = .8, tau = 1, p = 10)
#DML
data_proc_base <- DataAPDAutoDML(x = c(paste0("X_", 2:10)), d = "X_1",
y = "y" , data = DT, poly_order = 3,
interactions = TRUE,
unit = "fixed", time = "time")
auto_base <- rlassoAutoDML(data_proc_base, est_type = "APD" )
auto_base$te
DGP <- function(N, N_T = 10, rho = .8, tau = 1, p = 10){
# drawing fixed effects
a <- rnorm(N, 0, 5)
# id number for person
fixed <- rep(1:N, each = N_T)     # fixed effect dummies
# time label
time <- rep(1:N_T,  N)     # time
# creating base data
DT <- data.table(fixed, time, a = rep(a, each = N_T))
# create covar
# Create a data table with random normal values
var_names <- paste0("X_", 1:p) # creates the variable names X_1 through X_100
covar_DT <- data.table(matrix(rnorm(N*N_T * p),
nrow = N*N_T, ncol = p,
dimnames = list(NULL, var_names)))
DT <- cbind(DT, covar_DT)
#generate start y
DT[time == 1, y := a + tau*X_1 + .3*X_2]
# creating lag structure
for (year in c(2:N_T)){
DT[time == year, y := a + tau*X_1 + .3*X_2 +
+ .3*X_3 + .3*X_4 + .3*X_5 + .3*X_6 + .3*X_7  + .3*X_5 + .3*X_6 +
+ .3*X_7 + .3*X_8  + .3*X_9 + .3*X_10 +
rnorm(.N, mean=0, sd=1)]
}
# returning the data objects
return(DT)
}
DT <- DGP(N = 100 , N_T = 10, rho = .8, tau = 1, p = 10)
#DML
data_proc_base <- DataAPDAutoDML(x = c(paste0("X_", 2:10)), d = "X_1",
y = "y" , data = DT, poly_order = 3,
interactions = TRUE,
unit = "fixed", time = "time")
auto_base <- rlassoAutoDML(data_proc_base, est_type = "APD" )
auto_base$te
sqrt(1/2)
rm(list = ls())
remotes::install_github("MartinSpindler/hdm",
ref = "p-within", force = TRUE)
library(hdm)
library(data.table)
library(parallel)
library(xtable)
library(lfe)
library(MASS)
library(plm)
DGP <- function(N, N_T = 10, rho = .8, tau = 1, p = 10){
# drawing fixed effects
a <- rnorm(N, 0, 5)
# id number for person
fixed <- rep(1:N, each = N_T)     # fixed effect dummies
# time label
time <- rep(1:N_T,  N)     # time
# creating base data
DT <- data.table(fixed, time, a = rep(a, each = N_T))
# create covar
# Create a data table with random normal values
var_names <- paste0("X_", 1:p) # creates the variable names X_1 through X_100
covar_DT <- data.table(matrix(rnorm(N*N_T * p),
nrow = N*N_T, ncol = p,
dimnames = list(NULL, var_names)))
DT <- cbind(DT, covar_DT)
#generate start y
DT[time == 1, y := a + tau*X_1 + .3*X_2]
# creating lag structure
for (year in c(2:N_T)){
DT[time == year, y := a + tau*X_1 + .3*X_2 +
+ .3*X_3 + .3*X_4 + .3*X_5 + .3*X_6 + .3*X_7  + .3*X_5 + .3*X_6 +
+ .3*X_7 + .3*X_8  + .3*X_9 + .3*X_10 +
rnorm(.N, mean=0, sd=1)]
}
# returning the data objects
return(DT)
}
N = 100
N_T = 10
rho = .8
tau = 1
p = 10
DT <- DGP(N, N_T, rho, tau, p)
data_proc_base <- DataAPDAutoDML(x = c(paste0("X_", 2:10)), d = "X_1",
y = "y" , data = DT, poly_order = 3,
interactions = TRUE,
unit = "fixed", time = "time")
auto_base <- rlassoAutoDML(data_proc_base, est_type = "APD" )
(auto_base$te)
DT <- DGP(N, N_T, rho, tau, p)
#DML
data_proc_base <- DataAPDAutoDML(x = c(paste0("X_", 2:10)), d = "X_1",
y = "y" , data = DT, poly_order = 3,
interactions = TRUE,
unit = "fixed", time = "time")
auto_base <- rlassoAutoDML(data_proc_base, est_type = "APD" )
(auto_base$te)
DT <- DGP(N, N_T, rho, tau, p)
#DML
data_proc_base <- DataAPDAutoDML(x = c(paste0("X_", 2:10)), d = "X_1",
y = "y" , data = DT, poly_order = 3,
interactions = TRUE,
unit = "fixed", time = "time")
auto_base <- rlassoAutoDML(data_proc_base, est_type = "APD" )
(auto_base$te)
DT <- DGP(N, N_T, rho, tau, p)
#DML
data_proc_base <- DataAPDAutoDML(x = c(paste0("X_", 2:10)), d = "X_1",
y = "y" , data = DT, poly_order = 3,
interactions = TRUE,
unit = "fixed", time = "time")
auto_base <- rlassoAutoDML(data_proc_base, est_type = "APD" )
(auto_base$te)
DT <- DGP(N, N_T, rho, tau, p)
#DML
data_proc_base <- DataAPDAutoDML(x = c(paste0("X_", 2:10)), d = "X_1",
y = "y" , data = DT, poly_order = 3,
interactions = TRUE,
unit = "fixed", time = "time")
auto_base <- rlassoAutoDML(data_proc_base, est_type = "APD" )
(auto_base$te)
DT <- DGP(N, N_T, rho, tau, p)
#DML
data_proc_base <- DataAPDAutoDML(x = c(paste0("X_", 2:10)), d = "X_1",
y = "y" , data = DT, poly_order = 3,
interactions = TRUE,
unit = "fixed", time = "time")
auto_base <- rlassoAutoDML(data_proc_base, est_type = "APD" )
(auto_base$te)
DataAPDAutoDML
DataAPDAutoDML
DataAPDAutoDML <- function(x, d, y, x_manual = NULL, data, poly_order = 3,
interactions = TRUE, unit = NULL,
time = NULL) {
checkmate::check_character(x)
checkmate::check_character(d, max.len = 1)
checkmate::check_character(y, max.len = 1)
if (!is.null(x_manual)) {
checkmate::check_character(x_manual)
}
if (all(class(data) == "data.frame")) {
data = data.table::data.table(data)
}
checkmate::assert_class(data, "data.table")
checkmate::assert_character(names(data), unique = TRUE)
checkmate::check_numeric(poly_order, lower = 2, len = 1)
# Check if columns in data have positive variance and drop otherwise
const_cols <- names(which(apply(data, 2, function(x) var(x) < 10^(-5))))
if (length(const_cols) > 0) {
data[, c(const_cols):=NULL]
x <- x[x != const_cols ]
x_manual <- x_manual[x_manual != const_cols]
}
if(!is.null(unit) & !is.null(time)){
checkmate::check_character(unit, max.len = 1)
checkmate::check_character(time, max.len = 1)
# panel data clean by sorting
setorderv(data, c(unit, time))
}
p <- length(x)
n <- nrow(data)
all_vars <- c(x, d, y, x_manual)
data_prep <- data.table::copy(data[, ..all_vars])
d_cols <- character(length = poly_order)
d_cols[1] <- d
# X columns for polynomials (excluding binary x variables)
x_bin_indx <- apply(data_prep[, ..x], 2, function(x) { all(x %in% 0:1) })
x_bin <- names(data_prep[, ..x])[x_bin_indx]
x_notbin <- setdiff(x, x_bin)
p_notbin <- length(x_notbin)
if (p_notbin > 0) {
x_cols <- character(length = (p_notbin*poly_order))
x_cols[1:p_notbin] <- x_notbin
dx_names <- c(d, x_notbin)
} else {
x_cols <- x
dx_names <- d
}
# construct polynomials
for (pol_ord in 2:poly_order) {
d_cols_to_poly <- paste0(d, "_", pol_ord)
d_cols[pol_ord] <- d_cols_to_poly
new_cols_to_poly <- c(d_cols_to_poly)
if (p_notbin > 0) {
x_cols_to_poly <- paste0(x_notbin, "_", pol_ord)
x_cols[(((pol_ord - 1)*p_notbin + 1) : ((pol_ord - 1)*p_notbin + p_notbin))] <- x_cols_to_poly
new_cols_to_poly <- c(d_cols_to_poly, x_cols_to_poly)
}
data_prep[, paste0(new_cols_to_poly) := lapply(.SD, function(x) { x^pol_ord }), .SDcols = dx_names]
}
# generate interactions between covars x
if (interactions) {
cols_int_x_x <- paste0("int_", combn(x,2, FUN=paste, collapse='_'))
comb_covars <- combn(x, 2)
for (col in 1:length(comb_covars[1,])){
col_name_new <- paste0("int_", comb_covars[1, col], "_",
comb_covars[2, col] )
data_prep[[col_name_new]] <- data_prep[[comb_covars[1, col]]]*data_prep[[comb_covars[2, col]]]
if(length(unique(data_prep[[col_name_new]])) <= 1){
data_prep[[col_name_new]] <- NULL
}
}
cols_int_x_x <- intersect(colnames(data_prep), cols_int_x_x) # vector of final interactions
x_cols <- unique(c(x_cols, x_bin, cols_int_x_x))
} else {
x_cols <- unique(c(x_cols, x_bin))
}
# generate interactions for d with x
if (interactions) {
for (this_x in x) {
interaction_col_name <- paste0("int_", d, "_", this_x)
data_prep[[interaction_col_name]] <- data_prep[[d]] * data_prep[[this_x]]
}
}
# construct matrices M: manual derivative
cols_with_covars <- setdiff(names(data_prep), y)
M <- data.table::copy(data_prep[, ..cols_with_covars ])
M[[d]] <- rep(1, n)
for (pol_ord in 2:poly_order) {
this_d <- d_cols[pol_ord]
prev_d <- d_cols[pol_ord - 1]
M[[this_d]] <-  pol_ord * data_prep[[prev_d]]
}
# make all all columns that are not a function of D have deriv 0
M[, (x_cols) := lapply(.SD, function(x) { rep(0, n) }), .SDcols = x_cols]
if (!is.null(x_manual)) {
M[, (x_manual) := lapply(.SD, function(x) { rep(0, n) }), .SDcols = x_manual]
}
if (interactions) {
# derivative of X interacted with D is just X
for (this_x in x){
this_int <- paste0("int_", d, "_", this_x)
M[[this_int]] <- data_prep[[this_x]]
}
}
# Normalize M
# save the SD of the X matrix - we use these to normalize the M
basis_sd <- GMCM:::colSds(as.matrix(data_prep[,..cols_with_covars]))
M <- t(t(M)/basis_sd)
# normalize all covars in data_prep
data_prep[, (cols_with_covars) := lapply(.SD, function(x) { scale(x) }), .SDcols = cols_with_covars]
# if panel data take within transform
if(!is.null(unit) & !is.null(time)){
#handle data_prep first
## add back unit and time
data_prep$unit <- data[[unit]]
data_prep$time <- data[[time]]
all_vars <- c(cols_with_covars, y)
data_prep <- data_prep[, (all_vars  ) :=
lapply(.SD, function(v) {v - mean(v)}), .(unit),
.SDcols = all_vars ]
# because of the within transform the M matrix needs to be scaled by (1 - 1/T)
#M <- M*(1 - 1/max(data[[time]]))
}
# export Y and X as vector & matrix
Y <- data_prep[[y]]
X <- as.matrix(data_prep[, ..cols_with_covars])
M <- M
p <- ncol(X)
n <- nrow(X)
# Output
# data_prep: Preprocessed data table
# Y, X, M: Matrices
obj = list("data_prep" = data_prep, "M" = M,
"Y" = Y, "X" = X, "p" = p, "n" = n)
class(obj) <- "DataAPDAutoDML"
return(obj)
}
DataAPDAutoDML
#================
# Section 2: One Monte Carlo
#================
one_mc <- function(N, N_T = 10, rho = .8, tau = 1, p = 10){
DT <- DGP(N, N_T, rho, tau, p)
#DML
data_proc_base <- DataAPDAutoDML(x = c(paste0("X_", 2:10)), d = "X_1",
y = "y" , data = DT, poly_order = 3,
interactions = TRUE,
unit = "fixed", time = "time")
auto_base <- rlassoAutoDML(data_proc_base, est_type = "APD" )
(auto_base$te)
return(auto_base$te)
}
MC_num <- 100
monte_carlo_output <- mclapply(rep(100, MC_num),
one_mc, N_T = 5, rho = .6,
tau = 1)
MC_num <- 100
monte_carlo_output <- mclapply(rep(100, MC_num),
one_mc, N_T =10, rho = .6,
tau = 1)
monte_carlo_output <- Reduce(rbind, monte_carlo_output)
monte_carlo_output <- as.data.table(as.data.frame(monte_carlo_output))
bias_sd <- cbind(colMeans(monte_carlo_output), sapply(monte_carlo_output, sd))
table <- rbind(colMeans(monte_carlo_output),
sapply(monte_carlo_output, sd))
row.names(table) <- c("mean", "sd")
View(table)
library(synthdid)
DataAPDAutoDM
DataAPDAutoDML
remotes::install_github("MartinSpindler/hdm",
ref = "p-within", force = TRUE)
DataAPDAutoDM
DataAPDAutoDML
rm(list = ls())
DGP <- function(N, N_T = 10, rho = .8, tau = 1, p = 10){
# drawing fixed effects
a <- rnorm(N, 0, 5)
# id number for person
fixed <- rep(1:N, each = N_T)     # fixed effect dummies
# time label
time <- rep(1:N_T,  N)     # time
# creating base data
DT <- data.table(fixed, time, a = rep(a, each = N_T))
# create covar
# Create a data table with random normal values
var_names <- paste0("X_", 1:p) # creates the variable names X_1 through X_100
covar_DT <- data.table(matrix(rnorm(N*N_T * p),
nrow = N*N_T, ncol = p,
dimnames = list(NULL, var_names)))
DT <- cbind(DT, covar_DT)
#generate start y
DT[time == 1, y := a + tau*X_1 + .3*X_2]
# creating lag structure
for (year in c(2:N_T)){
DT[time == year, y := a + tau*X_1 + .3*X_2 +
+ .3*X_3 + .3*X_4 + .3*X_5 + .3*X_6 + .3*X_7 +
.3*X_8  + .3*X_9 + .3*X_10 +
rnorm(.N, mean=0, sd=1)]
}
# returning the data objects
return(DT)
}
#================
# Section 2: One Monte Carlo
#================
one_mc <- function(N, N_T = 10, rho = .8, tau = 1, p = 10){
DT <- DGP(N, N_T, rho, tau, p)
#DML
data_proc_base <- DataAPDAutoDML(x = c(paste0("X_", 2:10)), d = "X_1",
y = "y" , data = DT, poly_order = 3,
interactions = TRUE,
unit = "fixed", time = "time")
auto_base <- rlassoAutoDML(data_proc_base, est_type = "APD" )
(auto_base$te)
return(auto_base$te)
}
#================
# Section 3: Run Monte Carlo
#================
MC_num <- 100
monte_carlo_output <- mclapply(rep(100, MC_num),
one_mc, N_T =10, rho = .6,
tau = 1)
monte_carlo_output <- Reduce(rbind, monte_carlo_output)
monte_carlo_output <- as.data.table(as.data.frame(monte_carlo_output))
bias_sd <- cbind(colMeans(monte_carlo_output), sapply(monte_carlo_output, sd))
#======
# format table
#======
table <- rbind(colMeans(monte_carlo_output),
sapply(monte_carlo_output, sd))
row.names(table) <- c("mean", "sd")
colnames(table) <- c("rho", "tau",  paste0("X_", 2:30))
View(table)
MC_num <- 500
monte_carlo_output <- mclapply(rep(100, MC_num),
one_mc, N_T =10, rho = .6,
tau = 1)
monte_carlo_output <- Reduce(rbind, monte_carlo_output)
monte_carlo_output <- as.data.table(as.data.frame(monte_carlo_output))
bias_sd <- cbind(colMeans(monte_carlo_output), sapply(monte_carlo_output, sd))
#======
# format table
#======
table <- rbind(colMeans(monte_carlo_output),
sapply(monte_carlo_output, sd))
row.names(table) <- c("mean", "sd")
View(table)
View(table)
DataAPDAutoDML
remotes::install_github("MartinSpindler/hdm",
ref = "p-within", force = TRUE)
library(hdm)
DataAPDAutoDML
